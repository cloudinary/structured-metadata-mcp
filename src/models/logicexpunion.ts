/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { CondExp, CondExp$zodSchema } from "./condexp.js";

export type And2 = CondExp | LogicExp1 | LogicExp2;

export const And2$zodSchema: z.ZodType<And2, z.ZodTypeDef, unknown> = z.union([
  CondExp$zodSchema,
  z.union([
    z.lazy(() => LogicExp1$zodSchema),
    z.lazy(() => LogicExp2$zodSchema),
  ]),
]);

export type Or2 = CondExp | LogicExp1 | LogicExp2;

export const Or2$zodSchema: z.ZodType<Or2, z.ZodTypeDef, unknown> = z.union([
  CondExp$zodSchema,
  z.union([
    z.lazy(() => LogicExp1$zodSchema),
    z.lazy(() => LogicExp2$zodSchema),
  ]),
]);

export type LogicExp2 = {
  and?: Array<CondExp | LogicExp1 | LogicExp2> | undefined;
  or: Array<CondExp | LogicExp1 | LogicExp2>;
};

export const LogicExp2$zodSchema: z.ZodType<LogicExp2, z.ZodTypeDef, unknown> =
  z.object({
    and: z.array(z.union([
      CondExp$zodSchema,
      z.union([
        z.lazy(() => LogicExp1$zodSchema),
        z.lazy(() => LogicExp2$zodSchema),
      ]),
    ])).optional(),
    or: z.array(z.union([
      CondExp$zodSchema,
      z.union([
        z.lazy(() => LogicExp1$zodSchema),
        z.lazy(() => LogicExp2$zodSchema),
      ]),
    ])),
  });

export type And1 = CondExp | LogicExp1 | LogicExp2;

export const And1$zodSchema: z.ZodType<And1, z.ZodTypeDef, unknown> = z.union([
  CondExp$zodSchema,
  z.union([
    z.lazy(() => LogicExp1$zodSchema),
    z.lazy(() => LogicExp2$zodSchema),
  ]),
]);

export type Or1 = CondExp | LogicExp1 | LogicExp2;

export const Or1$zodSchema: z.ZodType<Or1, z.ZodTypeDef, unknown> = z.union([
  CondExp$zodSchema,
  z.union([
    z.lazy(() => LogicExp1$zodSchema),
    z.lazy(() => LogicExp2$zodSchema),
  ]),
]);

export type LogicExp1 = {
  and: Array<CondExp | LogicExp1 | LogicExp2>;
  or?: Array<CondExp | LogicExp1 | LogicExp2> | undefined;
};

export const LogicExp1$zodSchema: z.ZodType<LogicExp1, z.ZodTypeDef, unknown> =
  z.object({
    and: z.array(z.union([
      CondExp$zodSchema,
      z.union([
        z.lazy(() => LogicExp1$zodSchema),
        z.lazy(() => LogicExp2$zodSchema),
      ]),
    ])),
    or: z.array(z.union([
      CondExp$zodSchema,
      z.union([
        z.lazy(() => LogicExp1$zodSchema),
        z.lazy(() => LogicExp2$zodSchema),
      ]),
    ])).optional(),
  });

/**
 * Logical expression that combines multiple conditions using AND or OR operators.
 */
export type LogicExpUnion = LogicExp1 | LogicExp2;

export const LogicExpUnion$zodSchema: z.ZodType<
  LogicExpUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => LogicExp1$zodSchema),
  z.lazy(() => LogicExp2$zodSchema),
]).describe(
  "Logical expression that combines multiple conditions using AND or OR operators.",
);
